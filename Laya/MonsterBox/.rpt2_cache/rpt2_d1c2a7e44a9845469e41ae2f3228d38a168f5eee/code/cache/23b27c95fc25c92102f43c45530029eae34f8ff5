{
  "code": "import Mathf from \"./Mathf\";\r\nexport default (function () {\r\n    Laya.Vector3.prototype.vsub = function (v, target) {\r\n        var target = target || new Laya.Vector3();\r\n        Laya.Vector3.subtract(this, v, target);\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.vadd = function (v, target) {\r\n        var target = target || new Laya.Vector3();\r\n        Laya.Vector3.add(this, v, target);\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.mult = function (scalar, target) {\r\n        target = target || new Laya.Vector3();\r\n        var x = this.x, y = this.y, z = this.z;\r\n        target.x = scalar * x;\r\n        target.y = scalar * y;\r\n        target.z = scalar * z;\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.divide = function (scalar, target) {\r\n        target = target || new Laya.Vector3();\r\n        var x = this.x, y = this.y, z = this.z;\r\n        target.x = x / scalar;\r\n        target.y = y / scalar;\r\n        target.z = z / scalar;\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.cross = function (v, target) {\r\n        var vx = v.x, vy = v.y, vz = v.z, x = this.x, y = this.y, z = this.z;\r\n        var target = target || new Laya.Vector3();\r\n        target.x = (y * vz) - (z * vy);\r\n        target.y = (z * vx) - (x * vz);\r\n        target.z = (x * vy) - (y * vx);\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.dot = function (v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    };\r\n    Laya.Vector3.prototype.normalize = function () {\r\n        var num = this.magnitude();\r\n        if (num <= 1E-05)\r\n            this.set(0, 0, 0);\r\n        else\r\n            this.divide(num, this);\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.magnitude = function () {\r\n        return Mathf.Sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n    };\r\n    Laya.Vector3.prototype.magnitudeSquared = function () {\r\n        return this.dot(this);\r\n    };\r\n    Laya.Vector3.prototype.distanceTo = function (p) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var px = p.x, py = p.y, pz = p.z;\r\n        return Math.sqrt((px - x) * (px - x) +\r\n            (py - y) * (py - y) +\r\n            (pz - z) * (pz - z));\r\n    };\r\n    Laya.Vector3.prototype.distanceSquared = function (p) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var px = p.x, py = p.y, pz = p.z;\r\n        return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);\r\n    };\r\n    Laya.Vector3.prototype.scale = Laya.Vector3.prototype.mult;\r\n    Laya.Vector3.prototype.vmul = function (vector, target) {\r\n        target = target || new Laya.Vector3();\r\n        target.x = vector.x * this.x;\r\n        target.y = vector.y * this.y;\r\n        target.z = vector.z * this.z;\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.negate = function (target) {\r\n        target = target || new Laya.Vector3();\r\n        target.x = -this.x;\r\n        target.y = -this.y;\r\n        target.z = -this.z;\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.set = function (x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.copy = function (v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.toArray = function () {\r\n        return [this.x, this.y, this.z];\r\n    };\r\n    Laya.Vector3.prototype.fromArray = function (array, offset) {\r\n        if (offset === undefined)\r\n            offset = 0;\r\n        this.x = array[offset];\r\n        this.y = array[offset + 1];\r\n        this.z = array[offset + 2];\r\n        return this;\r\n    };\r\n    var Vec3_tangents_n = new Laya.Vector3();\r\n    var Vec3_tangents_randVec = new Laya.Vector3();\r\n    Laya.Vector3.prototype.tangents = function (t1, t2) {\r\n        var norm = this.norm();\r\n        if (norm > 0.0) {\r\n            var n = Vec3_tangents_n;\r\n            var inorm = 1 / norm;\r\n            n.set(this.x * inorm, this.y * inorm, this.z * inorm);\r\n            var randVec = Vec3_tangents_randVec;\r\n            if (Math.abs(n.x) < 0.9) {\r\n                randVec.set(1, 0, 0);\r\n                n.cross(randVec, t1);\r\n            }\r\n            else {\r\n                randVec.set(0, 1, 0);\r\n                n.cross(randVec, t1);\r\n            }\r\n            n.cross(t1, t2);\r\n        }\r\n        else {\r\n            t1.set(1, 0, 0);\r\n            t2.set(0, 1, 0);\r\n        }\r\n    };\r\n    Laya.Vector3.prototype.lerp = function (v, t, target) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        target.x = x + (v.x - x) * t;\r\n        target.y = y + (v.y - y) * t;\r\n        target.z = z + (v.z - z) * t;\r\n    };\r\n    Laya.Vector3.prototype.almostEquals = function (v, precision) {\r\n        if (precision === undefined) {\r\n            precision = 1e-6;\r\n        }\r\n        if (Math.abs(this.x - v.x) > precision ||\r\n            Math.abs(this.y - v.y) > precision ||\r\n            Math.abs(this.z - v.z) > precision) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    Laya.Vector3.prototype.isZero = function () {\r\n        return this.x === 0 && this.y === 0 && this.z === 0;\r\n    };\r\n    var antip_neg = new Laya.Vector3();\r\n    Laya.Vector3.prototype.isAntiparallelTo = function (v, precision) {\r\n        this.negate(antip_neg);\r\n        return antip_neg.almostEquals(v, precision);\r\n    };\r\n    Laya.Vector3.angle = function (from, to) {\r\n        var num = Mathf.Sqrt(from.magnitudeSquared() * to.magnitudeSquared());\r\n        return num >= 1E-15 ? Mathf.Acos(Mathf.Clamp(from.dot(to) / num, -1, 1)) * 57.29578 : 0;\r\n    };\r\n    Laya.Vector3.signedAngle = function (from, to, axis) {\r\n        return Laya.Vector3.angle(from, to) * Mathf.Sign(axis.dot(from.cross(to)));\r\n    };\r\n    Laya.Vector3.moveTowards = function (current, target, maxDistanceDelta, out) {\r\n        var out = out || new Laya.Vector3();\r\n        var vector = target.vsub(current);\r\n        var magnitude = vector.magnitude();\r\n        if (magnitude <= maxDistanceDelta || magnitude == 0)\r\n            out.copy(target);\r\n        else {\r\n            current.vadd(vector.divide(magnitude).mult(maxDistanceDelta), out);\r\n        }\r\n        return out;\r\n    };\r\n    Laya.Vector3.reflect = function (inDirection, inNormal, target) {\r\n        var target = target || new Laya.Vector3();\r\n        inNormal.mult(inNormal.dot(inDirection) * -2, target);\r\n        target.vadd(inDirection, target);\r\n        return target;\r\n    };\r\n    Laya.Vector3.prototype.min = function (v) {\r\n        this.x = Mathf.Min(this.x, v.x);\r\n        this.y = Mathf.Min(this.y, v.y);\r\n        this.z = Mathf.Min(this.z, v.z);\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.max = function (v) {\r\n        this.x = Mathf.Max(this.x, v.x);\r\n        this.y = Mathf.Max(this.y, v.y);\r\n        this.z = Mathf.Max(this.z, v.z);\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.applyMatrix3 = function (m) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var e = m.elements;\r\n        this.x = e[0] * x + e[3] * y + e[6] * z;\r\n        this.y = e[1] * x + e[4] * y + e[7] * z;\r\n        this.z = e[2] * x + e[5] * y + e[8] * z;\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.applyMatrix4 = function (m) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var e = m.elements;\r\n        var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\r\n        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\r\n        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\r\n        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.applyQuaternion = function (q) {\r\n        var x = this.x, y = this.y, z = this.z;\r\n        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n        var ix = qw * x + qy * z - qz * y;\r\n        var iy = qw * y + qz * x - qx * z;\r\n        var iz = qw * z + qx * y - qy * x;\r\n        var iw = -qx * x - qy * y - qz * z;\r\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.setFromMatrixPosition = function (m) {\r\n        var e = m.elements;\r\n        this.x = e[12];\r\n        this.y = e[13];\r\n        this.z = e[14];\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.setFromMatrixScale = function (m) {\r\n        var sx = this.setFromMatrixColumn(m, 0).magnitude();\r\n        var sy = this.setFromMatrixColumn(m, 1).magnitude();\r\n        var sz = this.setFromMatrixColumn(m, 2).magnitude();\r\n        this.x = sx;\r\n        this.y = sy;\r\n        this.z = sz;\r\n        return this;\r\n    };\r\n    Laya.Vector3.prototype.setFromMatrix3Column = function (m, index) {\r\n        return this.fromArray(m.elements, index * 3);\r\n    };\r\n    Laya.Vector3.prototype.setFromMatrixColumn = function (m, index) {\r\n        return this.fromArray(m.elements, index * 4);\r\n    };\r\n    Laya.Vector3.prototype.toString = function () {\r\n        return 'Vector3: ' + this.x + \", \" + this.y + \", \" + this.z;\r\n    };\r\n    Laya.Vector3.zero = new Laya.Vector3();\r\n    Laya.Vector3.one = new Laya.Vector3(1, 1, 1);\r\n    Laya.Vector3.up = new Laya.Vector3(0, 1, 0);\r\n    Laya.Vector3.down = new Laya.Vector3(0, -1, 0);\r\n    Laya.Vector3.forward = new Laya.Vector3(0, 0, 1);\r\n    Laya.Vector3.back = new Laya.Vector3(0, 0, -1);\r\n    Laya.Vector3.right = new Laya.Vector3(-1, 0, 0);\r\n    Laya.Vector3.left = new Laya.Vector3(1, 0, 0);\r\n})();\r\n",
  "references": [
    "D:/WorkSpace/Laya2.6.1/MonsterBox/src/script/Extensions/Mathf.ts"
  ]
}
