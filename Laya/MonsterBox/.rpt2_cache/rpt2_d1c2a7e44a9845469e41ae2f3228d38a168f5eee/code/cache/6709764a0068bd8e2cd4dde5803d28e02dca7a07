{
  "code": "var Vector2 = Laya.Vector2;\r\nimport Mathf from \"./Mathf\";\r\nvar zero = new Vector2();\r\nexport default (function () {\r\n    Vector2.prototype.vsub = function (v, target) {\r\n        var self = this;\r\n        var target = target || new Laya.Vector2();\r\n        target.x = self.x - v.x;\r\n        target.y = self.y - v.y;\r\n        return target;\r\n    };\r\n    Vector2.prototype.vadd = function (v, target) {\r\n        var self = this;\r\n        var target = target || new Laya.Vector2();\r\n        target.x = self.x + v.x;\r\n        target.y = self.y + v.y;\r\n        return target;\r\n    };\r\n    Vector2.prototype.mult = function (n, target) {\r\n        var target = target || new Vector2();\r\n        target.x = this.x * n;\r\n        target.y = this.y * n;\r\n        return target;\r\n    };\r\n    Vector2.prototype.divide = function (n, target) {\r\n        var target = target || new Vector2();\r\n        target.x = this.x / n;\r\n        target.y = this.y / n;\r\n        return target;\r\n    };\r\n    Vector2.prototype.dot = function (v) {\r\n        return this.x * v.x + this.y * v.y;\r\n    };\r\n    Vector2.prototype.lerp = function (a, t, target) {\r\n        t = Mathf.Clamp01(t);\r\n        var target = target || new Laya.Vector2();\r\n        target.x = this.x + ((a.x - this.x) * t);\r\n        target.y = this.y + ((a.y - this.y) * t);\r\n        return target;\r\n    };\r\n    Vector2.prototype.lerpUnclamped = function (a, t, target) {\r\n        var target = target || new Laya.Vector2();\r\n        target.x = this.x + ((a.x - this.x) * t);\r\n        target.y = this.y + ((a.y - this.y) * t);\r\n        return target;\r\n    };\r\n    Vector2.prototype.magnitude = function () {\r\n        return Mathf.Sqrt((this.x * this.x) + (this.y * this.y));\r\n    };\r\n    Vector2.moveTowards = function (current, target, maxDistanceDelta, out) {\r\n        var out = out || new Vector2();\r\n        var vector = target.vsub(current);\r\n        var magnitude = vector.magnitude();\r\n        if (magnitude <= maxDistanceDelta || magnitude == 0)\r\n            out.copy(target);\r\n        else {\r\n            current.vadd(vector.divide(magnitude).mult(maxDistanceDelta), out);\r\n        }\r\n        return out;\r\n    };\r\n    Vector2.prototype.normalize = function () {\r\n        let magnitude = this.magnitude();\r\n        if (magnitude <= 1E-05)\r\n            this.set(0, 0);\r\n        else\r\n            this.divide(magnitude, this);\r\n        return this;\r\n    };\r\n    Vector2.prototype.magnitudeSquared = function () {\r\n        return this.dot(this);\r\n    };\r\n    Vector2.prototype.unit = Vector2.prototype.normalize;\r\n    Vector2.prototype.distanceTo = function (p) {\r\n        var x = this.x, y = this.y;\r\n        var px = p.x, py = p.y;\r\n        return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y));\r\n    };\r\n    Vector2.prototype.distanceSquared = function (p) {\r\n        var x = this.x, y = this.y;\r\n        var px = p.x, py = p.y;\r\n        return (px - x) * (px - x) + (py - y) * (py - y);\r\n    };\r\n    Vector2.prototype.negate = function (target) {\r\n        target = target || new Laya.Vector2();\r\n        target.x = -this.x;\r\n        target.y = -this.y;\r\n        return target;\r\n    };\r\n    Vector2.prototype.copy = function (v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        return this;\r\n    };\r\n    Vector2.prototype.set = function (newX, newY) {\r\n        this.x = newX;\r\n        this.y = newY;\r\n    };\r\n    Vector2.prototype.toArray = function () {\r\n        return [this.x, this.y];\r\n    };\r\n    Vector2.prototype.fromArray = function (arr) {\r\n        this.x = arr[0];\r\n        this.y = arr[1];\r\n        this.z = arr[2];\r\n        return this;\r\n    };\r\n    Vector2.prototype.almostEquals = function (v, precision) {\r\n        if (precision === undefined) {\r\n            precision = 1e-6;\r\n        }\r\n        if (Math.abs(this.x - v.x) > precision || Math.abs(this.y - v.y) > precision) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    Vector2.prototype.isZero = function () {\r\n        return this.x === 0 && this.y === 0;\r\n    };\r\n    Vector2.prototype.min = function (v) {\r\n        this.x = Mathf.Min(this.x, v.x);\r\n        this.y = Mathf.Min(this.y, v.y);\r\n        return this;\r\n    };\r\n    Vector2.prototype.max = function (v) {\r\n        this.x = Mathf.Max(this.x, v.x);\r\n        this.y = Mathf.Max(this.y, v.y);\r\n        return this;\r\n    };\r\n    Vector2.angle = function (from, to) {\r\n        var num = Mathf.Sqrt(from.magnitudeSquared() * to.magnitudeSquared());\r\n        return num >= 1E-15 ? Mathf.Acos(Mathf.Clamp(from.dot(to) / num, -1, 1)) * 57.29578 : 0;\r\n    };\r\n    Vector2.signedAngle = function (from, to) {\r\n        return Vector2.angle(from, to) * Mathf.Sign(from.x * to.y - from.y * to.x);\r\n    };\r\n    Vector2.reflect = function (inDirection, inNormal, target) {\r\n        var target = target || new Vector2();\r\n        inNormal.mult(inNormal.dot(inDirection) * -2, target);\r\n        target.vadd(inDirection, target);\r\n        return target;\r\n    };\r\n    Vector2.prototype.toString = function () {\r\n        return 'Vector2: ' + this.x + \", \" + this.y;\r\n    };\r\n    Vector2.zero = new Vector2();\r\n    Vector2.one = new Vector2(1, 1);\r\n    Vector2.up = new Vector2(0, 1);\r\n    Vector2.down = new Vector2(0, -1);\r\n    Vector2.right = new Vector2(1, 0);\r\n    Vector2.left = new Vector2(-1, 0);\r\n})();\r\n",
  "references": [
    "D:/WorkSpace/Laya2.6.1/MonsterBox/src/script/Extensions/Mathf.ts"
  ]
}
