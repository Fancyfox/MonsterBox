{
  "code": "var Quaternion = Laya.Quaternion;\r\nimport Mathf from \"./Mathf\";\r\nexport default (function () {\r\n    Quaternion.prototype.vmult = function (v, target) {\r\n        var target = target || new Laya.Vector3();\r\n        var x = v.x, y = v.y, z = v.z;\r\n        var qx = this.x, qy = this.y, qz = this.z, qw = this.w;\r\n        var ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;\r\n        target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n        target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n        target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n        return target;\r\n    };\r\n    Quaternion.prototype.conjugate = function () {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    };\r\n    Quaternion.prototype.copy = function (s) {\r\n        this.x = s.x;\r\n        this.y = s.y;\r\n        this.z = s.z;\r\n        this.w = s.w;\r\n        return this;\r\n    };\r\n    Quaternion.prototype.setFromEuler = function (euler) {\r\n        var x = euler.x, y = euler.y, z = euler.z;\r\n        var cos = Math.cos;\r\n        var sin = Math.sin;\r\n        var c1 = cos(x / 2);\r\n        var c2 = cos(y / 2);\r\n        var c3 = cos(z / 2);\r\n        var s1 = sin(x / 2);\r\n        var s2 = sin(y / 2);\r\n        var s3 = sin(z / 2);\r\n        this.x = s1 * c2 * c3 + c1 * s2 * s3;\r\n        this.y = c1 * s2 * c3 - s1 * c2 * s3;\r\n        this.z = c1 * c2 * s3 + s1 * s2 * c3;\r\n        this.w = c1 * c2 * c3 - s1 * s2 * s3;\r\n        return this;\r\n    };\r\n    Quaternion.prototype.setFromAxisAngle = function (axis, angle) {\r\n        var halfAngle = angle / 2, s = Math.sin(halfAngle);\r\n        this.x = axis.x * s;\r\n        this.y = axis.y * s;\r\n        this.z = axis.z * s;\r\n        this.w = Math.cos(halfAngle);\r\n        return this;\r\n    };\r\n    Quaternion.prototype.setFromRotationMatrix = function (m) {\r\n        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;\r\n        if (trace > 0) {\r\n            s = 0.5 / Math.sqrt(trace + 1.0);\r\n            this.w = 0.25 / s;\r\n            this.x = (m32 - m23) * s;\r\n            this.y = (m13 - m31) * s;\r\n            this.z = (m21 - m12) * s;\r\n        }\r\n        else if (m11 > m22 && m11 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n            this.w = (m32 - m23) / s;\r\n            this.x = 0.25 * s;\r\n            this.y = (m12 + m21) / s;\r\n            this.z = (m13 + m31) / s;\r\n        }\r\n        else if (m22 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n            this.w = (m13 - m31) / s;\r\n            this.x = (m12 + m21) / s;\r\n            this.y = 0.25 * s;\r\n            this.z = (m23 + m32) / s;\r\n        }\r\n        else {\r\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n            this.w = (m21 - m12) / s;\r\n            this.x = (m13 + m31) / s;\r\n            this.y = (m23 + m32) / s;\r\n            this.z = 0.25 * s;\r\n        }\r\n        return this;\r\n    };\r\n    Quaternion.prototype.setFromUnitVectors = function (vFrom, vTo) {\r\n        var EPS = 0.000001;\r\n        var r = vFrom.dot(vTo) + 1;\r\n        if (r < EPS) {\r\n            r = 0;\r\n            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\r\n                this.x = -vFrom.y;\r\n                this.y = vFrom.x;\r\n                this.z = 0;\r\n                this.w = r;\r\n            }\r\n            else {\r\n                this.x = 0;\r\n                this.y = -vFrom.z;\r\n                this.z = vFrom.y;\r\n                this.w = r;\r\n            }\r\n        }\r\n        else {\r\n            this.x = vFrom.y * vTo.z - vFrom.z * vTo.y;\r\n            this.y = vFrom.z * vTo.x - vFrom.x * vTo.z;\r\n            this.z = vFrom.x * vTo.y - vFrom.y * vTo.x;\r\n            this.w = r;\r\n        }\r\n        return this.normalize();\r\n    };\r\n    Quaternion.prototype.angleTo = function (q) {\r\n        return 2 * Math.acos(Math.abs(Mathf.Clamp(this.dot(q), -1, 1)));\r\n    };\r\n    Quaternion.prototype.rotateTowards = function (q, step) {\r\n        var angle = this.angleTo(q);\r\n        if (angle === 0)\r\n            return this;\r\n        var t = Math.min(1, step / angle);\r\n        this.slerp(q, t);\r\n        return this;\r\n    };\r\n    Quaternion.prototype.inverse = function () {\r\n        return this.conjugate();\r\n    };\r\n    Quaternion.prototype.dot = function (v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    };\r\n    Quaternion.prototype.lengthSq = function () {\r\n        return this.dot(this);\r\n    };\r\n    Quaternion.prototype.length = function () {\r\n        return Math.sqrt(this.dot(this));\r\n    };\r\n    Quaternion.prototype.normalize = function () {\r\n        var l = this.length();\r\n        if (l === 0) {\r\n            this.x = 0;\r\n            this.y = 0;\r\n            this.z = 0;\r\n            this.w = 1;\r\n        }\r\n        else {\r\n            l = 1 / l;\r\n            this.x = this.x * l;\r\n            this.y = this.y * l;\r\n            this.z = this.z * l;\r\n            this.w = this.w * l;\r\n        }\r\n        return this;\r\n    };\r\n    Quaternion.prototype.multiply = function (q) {\r\n        return this.multiplyQuaternions(this, q);\r\n    };\r\n    Quaternion.prototype.premultiply = function (q) {\r\n        return this.multiplyQuaternions(q, this);\r\n    };\r\n    Quaternion.prototype.multiplyQuaternions = function (a, b) {\r\n        var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\r\n        var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\r\n        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n        return this;\r\n    };\r\n    Quaternion.prototype.slerp = function (qb, t) {\r\n        if (t === 0)\r\n            return this;\r\n        if (t === 1)\r\n            return this.copy(qb);\r\n        var x = this.x, y = this.y, z = this.z, w = this.w;\r\n        var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;\r\n        if (cosHalfTheta < 0) {\r\n            this.w = -qb.w;\r\n            this.x = -qb.x;\r\n            this.y = -qb.y;\r\n            this.z = -qb.z;\r\n            cosHalfTheta = -cosHalfTheta;\r\n        }\r\n        else {\r\n            this.copy(qb);\r\n        }\r\n        if (cosHalfTheta >= 1.0) {\r\n            this.w = w;\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n            return this;\r\n        }\r\n        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\r\n        if (sqrSinHalfTheta <= Number.EPSILON) {\r\n            var s = 1 - t;\r\n            this.w = s * w + t * this.w;\r\n            this.x = s * x + t * this.x;\r\n            this.y = s * y + t * this.y;\r\n            this.z = s * z + t * this.z;\r\n            this.normalize();\r\n            return this;\r\n        }\r\n        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\r\n        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\r\n        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\r\n        this.w = (w * ratioA + this.w * ratioB);\r\n        this.x = (x * ratioA + this.x * ratioB);\r\n        this.y = (y * ratioA + this.y * ratioB);\r\n        this.z = (z * ratioA + this.z * ratioB);\r\n        return this;\r\n    };\r\n    Quaternion.prototype.equals = function (quaternion) {\r\n        return (quaternion.x === this.x) && (quaternion.y === this.y) && (quaternion.z === this.z) && (quaternion.w === this.w);\r\n    };\r\n    Quaternion.prototype.fromArray = function (arr) {\r\n        this.x = arr[0];\r\n        this.y = arr[1];\r\n        this.z = arr[2];\r\n        this.w = arr[3];\r\n        return this;\r\n    };\r\n    Quaternion.prototype.toArray = function () {\r\n        return [this.x, this.y, this.z, this.w];\r\n    };\r\n    Quaternion.prototype.toString = function () {\r\n        return 'Quaternion: ' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w;\r\n    };\r\n})();\r\n",
  "references": [
    "D:/WorkSpace/Laya2.6.1/MonsterBox/src/script/Extensions/Mathf.ts"
  ]
}
