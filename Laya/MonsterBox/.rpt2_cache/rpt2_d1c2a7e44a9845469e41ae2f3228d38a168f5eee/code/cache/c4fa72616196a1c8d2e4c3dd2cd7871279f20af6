{
  "code": "export default class Mathf {\r\n    static Sin(f) {\r\n        return Math.sin(f);\r\n    }\r\n    static Cos(f) {\r\n        return Math.cos(f);\r\n    }\r\n    static Tan(f) {\r\n        return Math.tan(f);\r\n    }\r\n    static Asin(f) {\r\n        return Math.asin(f);\r\n    }\r\n    static Acos(f) {\r\n        return Math.acos(f);\r\n    }\r\n    static Atan(f) {\r\n        return Math.atan(f);\r\n    }\r\n    static Atan2(y, x) {\r\n        return Math.atan2(y, x);\r\n    }\r\n    static Sqrt(f) {\r\n        return Math.sqrt(f);\r\n    }\r\n    static Abs(f) {\r\n        return Math.abs(f);\r\n    }\r\n    static Random(min, max, float = true) {\r\n        return float ? Math.random() * (max - min) + min : Math.floor(Math.random() * (max - min) + min);\r\n    }\r\n    static Min(...values) {\r\n        let length = values.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n        let num3 = values[0];\r\n        for (let i = 1; i < length; i++) {\r\n            if (values[i] < num3) {\r\n                num3 = values[i];\r\n            }\r\n        }\r\n        return num3;\r\n    }\r\n    static Max(...values) {\r\n        let length = values.length;\r\n        if (length == 0) {\r\n            return 0;\r\n        }\r\n        let num3 = values[0];\r\n        for (let i = 1; i < length; i++) {\r\n            if (values[i] > num3) {\r\n                num3 = values[i];\r\n            }\r\n        }\r\n        return num3;\r\n    }\r\n    static Pow(f, p) {\r\n        return Math.pow(f, p);\r\n    }\r\n    static Exp(power) {\r\n        return Math.exp(power);\r\n    }\r\n    static Log(f) {\r\n        return Math.log(f);\r\n    }\r\n    static Log10(f) {\r\n        return Math.log10(f);\r\n    }\r\n    static Ceil(f) {\r\n        return Math.ceil(f);\r\n    }\r\n    static Floor(f) {\r\n        return Math.floor(f);\r\n    }\r\n    static Round(f, n = 0) {\r\n        let d = this.Pow(10, n);\r\n        return Math.floor(f * d + 0.5) / d;\r\n    }\r\n    static RoundVector3(v, n = 0) {\r\n        v.x = this.Round(v.x, n);\r\n        v.y = this.Round(v.y, n);\r\n        v.z = this.Round(v.z, n);\r\n    }\r\n    static Sign(f) {\r\n        return ((f < 0) ? -1 : 1);\r\n    }\r\n    static Clamp(value, min, max) {\r\n        if (value < min) {\r\n            value = min;\r\n            return value;\r\n        }\r\n        if (value > max) {\r\n            value = max;\r\n        }\r\n        return value;\r\n    }\r\n    static Clamp01(value) {\r\n        if (value < 0) {\r\n            return 0;\r\n        }\r\n        if (value > 1) {\r\n            return 1;\r\n        }\r\n        return value;\r\n    }\r\n    static Lerp(a, b, t) {\r\n        return (a + ((b - a) * this.Clamp01(t)));\r\n    }\r\n    static LerpUnclamped(a, b, t) {\r\n        return (a + ((b - a) * t));\r\n    }\r\n    static LerpAngle(a, b, t) {\r\n        let num = this.Repeat(b - a, 360);\r\n        if (num > 180) {\r\n            num -= 360;\r\n        }\r\n        return (a + (num * this.Clamp01(t)));\r\n    }\r\n    static MoveTowards(current, target, maxDelta) {\r\n        if (this.Abs((target - current)) <= maxDelta) {\r\n            return target;\r\n        }\r\n        return (current + (this.Sign(target - current) * maxDelta));\r\n    }\r\n    static MoveTowardsAngle(current, target, maxDelta) {\r\n        let num = this.DeltaAngle(current, target);\r\n        if ((-maxDelta < num) && (num < maxDelta)) {\r\n            return target;\r\n        }\r\n        target = current + num;\r\n        return this.MoveTowards(current, target, maxDelta);\r\n    }\r\n    static SmoothStep(from, to, t) {\r\n        t = this.Clamp01(t);\r\n        t = (((-2 * t) * t) * t) + ((3 * t) * t);\r\n        return ((to * t) + (from * (1 - t)));\r\n    }\r\n    static Gamma(value, absmax, gamma) {\r\n        let flag = false;\r\n        if (value < 0) {\r\n            flag = true;\r\n        }\r\n        let num = this.Abs(value);\r\n        if (num > absmax) {\r\n            return (!flag ? num : -num);\r\n        }\r\n        let num3 = this.Pow(num / absmax, gamma) * absmax;\r\n        return (!flag ? num3 : -num3);\r\n    }\r\n    static Repeat(t, length) {\r\n        return this.Clamp(t - (this.Floor(t / length) * length), 0, length);\r\n    }\r\n    static PingPong(t, length) {\r\n        t = this.Repeat(t, length * 2);\r\n        return (length - this.Abs((t - length)));\r\n    }\r\n    static InverseLerp(a, b, value) {\r\n        if (a != b) {\r\n            return this.Clamp01((value - a) / (b - a));\r\n        }\r\n        return 0;\r\n    }\r\n    static DeltaAngle(current, target) {\r\n        let num = this.Repeat(target - current, 360);\r\n        if (num > 180) {\r\n            num -= 360;\r\n        }\r\n        return num;\r\n    }\r\n    static SmoothDamp(current, target, currentVelocity, smoothTime, maxSpeed = Number.MAX_SAFE_INTEGER, deltaTime = Laya.timer.delta * 0.001) {\r\n        smoothTime = this.Max(0.0001, smoothTime);\r\n        let num = 2 / smoothTime;\r\n        let num2 = num * deltaTime;\r\n        let num3 = 1 / (((1 + num2) + ((0.48 * num2) * num2)) + (((0.235 * num2) * num2) * num2));\r\n        let num4 = current - target;\r\n        let num5 = target;\r\n        let max = maxSpeed * smoothTime;\r\n        num4 = this.Clamp(num4, -max, max);\r\n        target = current - num4;\r\n        let num7 = (currentVelocity + (num * num4)) * deltaTime;\r\n        currentVelocity = (currentVelocity - (num * num7)) * num3;\r\n        let num8 = target + ((num4 + num7) * num3);\r\n        if (((num5 - current) > 0) == (num8 > num5)) {\r\n            num8 = num5;\r\n            currentVelocity = (num8 - num5) / deltaTime;\r\n        }\r\n        return { value: num8, currentVelocity };\r\n    }\r\n    static LineIntersection(p1, p2, p3, p4, result) {\r\n        let num = p2.x - p1.x;\r\n        let num2 = p2.y - p1.y;\r\n        let num3 = p4.x - p3.x;\r\n        let num4 = p4.y - p3.y;\r\n        let num5 = (num * num4) - (num2 * num3);\r\n        if (num5 == 0) {\r\n            return false;\r\n        }\r\n        let num6 = p3.x - p1.x;\r\n        let num7 = p3.y - p1.y;\r\n        let num8 = ((num6 * num4) - (num7 * num3)) / num5;\r\n        result = new Laya.Vector2(p1.x + (num8 * num), p1.y + (num8 * num2));\r\n        return true;\r\n    }\r\n    static LineSegmentIntersection(p1, p2, p3, p4, result) {\r\n        let num = p2.x - p1.x;\r\n        let num2 = p2.y - p1.y;\r\n        let num3 = p4.x - p3.x;\r\n        let num4 = p4.y - p3.y;\r\n        let num5 = (num * num4) - (num2 * num3);\r\n        if (num5 == 0) {\r\n            return false;\r\n        }\r\n        let num6 = p3.x - p1.x;\r\n        let num7 = p3.y - p1.y;\r\n        let num8 = ((num6 * num4) - (num7 * num3)) / num5;\r\n        if ((num8 < 0) || (num8 > 1)) {\r\n            return false;\r\n        }\r\n        let num9 = ((num6 * num2) - (num7 * num)) / num5;\r\n        if ((num9 < 0) || (num9 > 1)) {\r\n            return false;\r\n        }\r\n        result = new Laya.Vector2(p1.x + (num8 * num), p1.y + (num8 * num2));\r\n        return true;\r\n    }\r\n}\r\nMathf.PI = 3.141593;\r\nMathf.Infinity = Number.MAX_SAFE_INTEGER;\r\nMathf.NegativeInfinity = Number.MIN_SAFE_INTEGER;\r\nMathf.Deg2Rad = 0.01745329;\r\nMathf.Rad2Deg = 57.29578;\r\n",
  "references": []
}
